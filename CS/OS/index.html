<!-- build time:Fri Jun 30 2023 18:02:35 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="http://lovearrowshoot.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" href="http://lovearrowshoot.github.io/atom.xml"><link rel="alternate" type="application/json" href="http://lovearrowshoot.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="计算机科学"><link rel="canonical" href="http://lovearrowshoot.github.io/CS/OS/"><title>操作系统 - 计算机科学 | umiの道場 = = ❤Love Arrow Shoot!❤</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">操作系统</h1><div class="meta"><span class="item" title="创建时间：2023-06-30 10:29:20"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-06-30T10:29:20+08:00">2023-06-30</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>5.8k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>5 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">umiの道場</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://umi-blog-delta.vercel.app/gh/LoveArrowShoot/image-bed@main/blog-img/317SR-Sonoda-Umi-The-area-by-the-river-is-slippery-Wonderful-Rush-ndDqti.png"></li><li class="item" data-background-image="https://umi-blog-delta.vercel.app/gh/LoveArrowShoot/image-bed@main/blog-img/670UR-Yazawa-Nico-Leave-Making-the-Cake-to-Me-Lovely-Berries-ykq014.png"></li><li class="item" data-background-image="https://umi-blog-delta.vercel.app/gh/LoveArrowShoot/image-bed@main/blog-img/315UR-Toujou-Nozomi-Here-it-s-snack-time-Colorful-Konpeito-PsVXRD.png"></li><li class="item" data-background-image="https://umi-blog-delta.vercel.app/gh/LoveArrowShoot/image-bed@main/blog-img/806SR-Ayase-Eli-They-Taste-Amazing-Too-Mermaid-festa-vol-1-p3TI65.png"></li><li class="item" data-background-image="https://umi-blog-delta.vercel.app/gh/LoveArrowShoot/image-bed@main/blog-img/477UR-Ayase-Eli-Not-bad-for-a-change-Glistening-Flower-in-the-Rain-xbwEjn.png"></li><li class="item" data-background-image="https://umi-blog-delta.vercel.app/gh/LoveArrowShoot/image-bed@main/blog-img/778SR-Tojo-Nozomi-Why-Don-t-We-Play-with-Some-Stakes-Mermaid-festa-vol-1-wDNbXG.png"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CS/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://lovearrowshoot.github.io/CS/OS/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Umi"><meta itemprop="description" content="❤Love Arrow Shoot!❤, 这只是我闲着无聊搭的一个博客，主要用于存放笔记，顺便厨力放出"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><h1 id="概览"><a class="anchor" href="#概览">#</a> 概览</h1><ol><li>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</li><li>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</li><li>操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li><li>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li></ol><h2 id="系统调用"><a class="anchor" href="#系统调用">#</a> 系统调用</h2><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p><p>用户态 (user mode) : 用户态运行的进程可以直接读取用户程序的数据。</p><p>系统态 (kernel mode): 可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</p><p>我们运行的程序基本都是运行在用户态，也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。这些系统调用按功能大致可分为如下几类：</p><ul><li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li><li>文件管理。完成文件的读、写、创建及删除等功能。</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li><li>进程通信。完成进程之间的消息传递或信号传递等功能。</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li><li><img data-src="452eaa10218c49e03390896987bbe9fd.png" alt="截图"></li></ul><h2 id="硬件结构"><a class="anchor" href="#硬件结构">#</a> 硬件结构</h2><h3 id="冯诺依曼模型"><a class="anchor" href="#冯诺依曼模型">#</a> 冯诺依曼模型</h3><p><img data-src="641e410538abd5e3ea7febb846abfe15.png" alt="截图"></p><h3 id="存储器层次关系"><a class="anchor" href="#存储器层次关系">#</a> 存储器层次关系</h3><p><img data-src="7e690ef1763726a91b5ac07c2f8e93cf.png" alt="截图"></p><h1 id="内存管理"><a class="anchor" href="#内存管理">#</a> 内存管理</h1><h2 id="虚拟内存"><a class="anchor" href="#虚拟内存">#</a> 虚拟内存</h2><ol><li><strong>虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。</strong></li><li><strong>由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。</strong></li><li><strong>页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。</strong></li></ol><h2 id="内存分页"><a class="anchor" href="#内存分页">#</a> 内存分页</h2><p>在 Linux 下，每一页的大小为 4KB</p><p><img data-src="b1c9ab095015145af4e420d401f5e10e.png" alt="截图"></p><h2 id="内存分段"><a class="anchor" href="#内存分段">#</a> 内存分段</h2><p><img data-src="505f014934e8bd3730a53baf3da58d3c.png" alt="截图"></p><h2 id="段页式内存"><a class="anchor" href="#段页式内存">#</a> 段页式内存</h2><p><img data-src="ab1468bc9813d44902b131553259f04c.png" alt="截图"></p><h2 id="linux内存"><a class="anchor" href="#linux内存">#</a> Linux 内存</h2><p><img data-src="1747399eeb06fb7901de17323539b8b5.png" alt="截图"></p><p>虽然每个进程都各自有独立的虚拟内存，但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存。这样，进程切换到内核态后，就可以很方便地访问内核空间内存</p><p><img data-src="feda7e0fd68f52a80f47a2e0b7a80cdc.png" alt="截图"></p><ul><li>代码段，包括二进制可执行代码；</li><li>数据段，包括已初始化的静态常量和全局变量；</li><li>BSS 段，包括未初始化的静态变量和全局变量；</li><li>堆段，包括动态分配的内存，从低地址开始向上增长；</li><li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长</li><li>栈段，包括局部变量和函数调用的上下文等。栈的大小固定</li></ul><h2 id="内存回收"><a class="anchor" href="#内存回收">#</a> 内存回收</h2><p><img data-src="d422671507c85bc8f23b03eb9f88166e.png" alt="截图"></p><h2 id="页面置换算法"><a class="anchor" href="#页面置换算法">#</a> 页面置换算法</h2><ul><li><strong>Clock 页面置换算法（时钟页面置换算法）把所有的页面都保存在一个环形链表中，表针指向最老的页面。当发生缺页中断时，算法检查表针指向的页面：如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；然后将该页面淘汰，插入新页面</strong></li><li><strong>OPT 页面置换算法（最佳页面置换算法） ：最佳 (Optimal, OPT) 置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。</strong></li><li><strong>FIFO 页面置换算法（先进先出页面置换算法） : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</strong></li><li><strong>LRU 页面置换算法（最近最久未使用页面置换算法） ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</strong></li><li><strong>LFU 页面置换算法（最少使用页面置换算法） : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</strong></li></ul><h2 id="lru算法改进"><a class="anchor" href="#lru算法改进">#</a> LRU 算法改进</h2><p>传统的 LRU 算法无法避免下面这两个问题：</p><blockquote><p><strong>预读失效导致缓存命中率下降<br>缓存污染导致缓存命中率下降</strong></p></blockquote><ul><li>为了避免「预读失效」造成的影响</li></ul><p>Linux 操作系统实现两个了 LRU 链表：活跃 LRU 链表和非活跃 LRU 链表</p><p>MySQL Innodb 存储引擎是一个 LRU 链表上划分来 2 个区域：young 区域 和 old 区域。</p><p>预读页就只需要加入到非活跃链表头部，当页被真正访问的时候，才将页插入活跃链表头部，而将尾部的页降级为非活跃链表头部；如果预读的页一直没有被访问，就会从非活跃链表移除，这样就不会影响活跃链表中的热点数据。</p><ul><li>为了避免「缓存污染」造成的影响，提高了升级为热点数据的门槛：</li></ul><p>Linux 操作系统：在内存页被访问第二次的时候，将页从非活跃链表升级到活跃链表</p><p>MySQL Innodb：在内存页被访问第二次的时候，进行停留在 old 区域的时间判断：</p><blockquote><p><strong>如果第二次的访问时间与第一次访问的时间在 1 秒内（默认值），那么该页就不会被从 old 区域升级到 young 区域</strong></p><p><strong>如果第二次的访问时间与第一次访问的时间超过 1 秒，那么该页就会从 old 区域升级到 young 区域</strong></p></blockquote><h1 id="进程管理"><a class="anchor" href="#进程管理">#</a> 进程管理</h1><h2 id="进程和线程"><a class="anchor" href="#进程和线程">#</a> 进程和线程</h2><ul><li>进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；</li><li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</li><li>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li><li>线程能减少并发执行的时间和空间开销；</li><li>线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</li><li>线程的终止时间比进程快，因为线程释放的资源相比进程少很多；</li><li>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</li><li>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；</li></ul><h2 id="进程状态"><a class="anchor" href="#进程状态">#</a> 进程状态</h2><p><img data-src="cc43f19d22fc56c1a3b852670cc83372.png" alt="截图"></p><ul><li><strong>运行状态（Running）：该时刻进程占用 CPU；</strong></li><li><strong>就绪状态（Ready）：可运行，由于其他进程处于运行状态而暂时停止运行；</strong></li><li><strong>阻塞状态（Blocked）：该进程正在等待某一事件发生（如等待输入 / 输出操作的完成）而暂时停止运行，这时，即使给它 CPU 控制权，它也无法运行；</strong></li><li><strong>创建状态（new）：进程正在被创建时的状态；</strong></li><li><strong>结束状态（Exit）：进程正在从系统中消失时的状态；</strong></li><li><strong>阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；</strong></li><li><strong>就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；</strong></li></ul><h2 id="进程控制"><a class="anchor" href="#进程控制">#</a> 进程控制</h2><h3 id="pcb进程控制块"><a class="anchor" href="#pcb进程控制块">#</a> PCB（进程控制块）</h3><p>PCB 是进程存在的唯一标识</p><ul><li><p>进程描述信息：</p><p>进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；</p><p>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；</p></li><li><p>进程控制和管理信息：</p><p>进程当前状态，如 new、ready、running、waiting 或 blocked 等；</p><p>进程优先级：进程抢占 CPU 时的优先级；</p></li><li><p>资源分配清单：有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。</p></li><li><p>CPU 相关信息：CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。</p></li></ul><h2 id="进程调度算法"><a class="anchor" href="#进程调度算法">#</a> 进程调度算法</h2><ul><li><p>先到先服务 (FCFS) 调度算法：从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</p></li><li><p>短作业优先 (SJF) 调度算法：从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度</p></li><li><p>高响应比优先 (HRRN) 调度算法：每次进行进程调度时，计算「响应比优先级」，把「响应比优先级」最高的进程投入运行，优先级 =(等待时间 + 要求服务时间)/ 要求服务时间</p></li><li><p>时间片轮转 (RR) 调度算法：时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</p></li><li><p>最高优先级调度 ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。</p></li><li><p>多级反馈队列调度算法 ：</p><p>设置了多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，同时优先级越高时间片越短；</p><p>新进程会被放入到第一级队列的末尾，按先来先服务排队等待被调度，如果在第一级队列规定的时间片没运行完成，则转入到第二级队列的末尾，以此类推，直至完成；</p><p>当较高优先级的队列为空，调度较低优先级的队列中的进程运行。进程运行时，有新进程进入较高优先级的队列，停止当前运行的进程并移入到原队列末尾，让较高优先级的进程运行；</p></li></ul><h2 id="进程通信"><a class="anchor" href="#进程通信">#</a> 进程通信</h2><p>匿名管道 (Pipes) ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</p><p>有名管道 (Named Pipes) : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出 (first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</p><p>信号 (Signal) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</p><p>消息队列 (Message Queuing) ：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道不同的是消息队列存放在内核中，只有在内核重启或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。</p><p>信号量 (Semaphores) ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</p><p>共享内存 (Shared memory) ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</p><p>套接字 (Sockets) : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p><h2 id="线程冲突"><a class="anchor" href="#线程冲突">#</a> 线程冲突</h2><p>锁 解决互斥问题</p><p>信号量 解决互斥问题和同步问题</p><h2 id="死锁"><a class="anchor" href="#死锁">#</a> 死锁</h2><h3 id="产生条件"><a class="anchor" href="#产生条件">#</a> 产生条件</h3><blockquote><p><strong>互斥</strong></p><p><strong>持有并等待</strong></p><p><strong>不可剥夺</strong></p><p><strong>循环等待</strong></p></blockquote><h3 id="解决方式"><a class="anchor" href="#解决方式">#</a> 解决方式</h3><blockquote><p>预防：有序分配，静态分配</p><p>避免：银行家算法</p><p>检测：进程 - 资源分配图</p><p>解除：杀死进程，抢占资源</p></blockquote><h1 id="文件系统"><a class="anchor" href="#文件系统">#</a> 文件系统</h1><h2 id="基本组成"><a class="anchor" href="#基本组成">#</a> 基本组成</h2><p><img data-src="69da5b519dab3f692378d7e11e9dfee2.png" alt="截图"></p><p><img data-src="bdffa32e767fdc739256a54c0550a126.png" alt="截图"></p><ul><li>超级块，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等</li><li>索引节点区，用来存储索引节点</li><li>数据块区，用来存储文件或目录数据</li></ul><h2 id="文件存储"><a class="anchor" href="#文件存储">#</a> 文件存储</h2><h3 id="索引方式"><a class="anchor" href="#索引方式">#</a> 索引方式</h3><p><img data-src="237d55c9ee85ea7f67c25d894d6053ec.png" alt="截图"></p><p>&lt;br/&gt;</p><h3 id="存储结构"><a class="anchor" href="#存储结构">#</a> 存储结构</h3><p><img data-src="3112dbef2261170eb9ea93d8917268bc.png" alt="截图"></p><ul><li>超级块，包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等</li><li>块组描述符，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」</li><li>数据位图和 inode 位图， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。<br>inode 列表，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据</li><li>数据块，包含文件的有用数据</li></ul><h2 id="文件io"><a class="anchor" href="#文件io">#</a> 文件 IO</h2><p><img data-src="64149890e7d2352e9c6d00296ff1f94c.png" alt="截图"></p><p>I/O 分为两个过程的：</p><blockquote><p>数据准备的过程<br>数据从内核空间拷贝到用户进程缓冲区的过程</p></blockquote><p>阻塞 I/O 阻塞在「过程 1 」和「过程 2」</p><p>非阻塞 I/O 和基于非阻塞 I/O 的多路复用阻塞在「过程 2」</p><p>异步 I/O 在「过程 1 」和「过程 2 」都不会阻塞</p><h1 id="网络系统"><a class="anchor" href="#网络系统">#</a> 网络系统</h1><h2 id="网络传输"><a class="anchor" href="#网络传输">#</a> 网络传输</h2><h3 id="传统拷贝"><a class="anchor" href="#传统拷贝">#</a> 传统拷贝</h3><p><img data-src="9fb013bdbbf80a5259c47035f172f860.png" alt="截图"></p><h3 id="零拷贝"><a class="anchor" href="#零拷贝">#</a> 零拷贝</h3><p><img data-src="182081744abce78af7b790e71a1566e7.png" alt="截图"></p><p>零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</p><p><img data-src="6738a5b5d1756b5272b416be3c131dec.png" alt="1683564006371.png"></p><h2 id="io多路复用"><a class="anchor" href="#io多路复用">#</a> IO 多路复用</h2><h3 id="selectpoll"><a class="anchor" href="#selectpoll">#</a> select/poll</h3><ul><li>已连接的 Socket 都放到一个文件描述符集合，调用 select 函数将文件描述符集合拷贝到内核</li><li>内核遍历文件描述符集合，当检查到有事件产生后，将此 Socket 标记为可读或可写，再把整个文件描述符集合拷贝回用户态</li><li>用户态通过遍历的方法找到可读或可写的 Socket，然后处理</li></ul><h3 id="epoll"><a class="anchor" href="#epoll">#</a> epoll</h3><p><img data-src="4ed8729089682ebeb559a10533479965.png" alt="截图"></p><p>使用事件驱动机制，内核维护了一个链表记录就绪事件，当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，用户调用 epoll_wait () 函数时，返回有事件发生的文件描述符的个数</p><h2 id="网络模式"><a class="anchor" href="#网络模式">#</a> 网络模式</h2><h3 id="reactor"><a class="anchor" href="#reactor">#</a> Reactor</h3><p>单 Reactor 单进程</p><p><img data-src="21557e97899912aa1be0df34980f6462.png" alt="截图"></p><p>单 Reactor 多进程</p><p><img data-src="65da303e36f2083abeb41b9064799cb6.png" alt="截图"></p><p>多 Reactor 多进程</p><p><img data-src="39835bde9e939b9f917d9c6175b2e072.png" alt="截图"></p><h3 id="proactor"><a class="anchor" href="#proactor">#</a> Proactor</h3><p><img data-src="0a3c51901c46b3bc804d3e784a5009ce.png" alt="截图"></p><ul><li>Proactor Initiator 负责创建 Proactor 和 Handler 对象，并将 Proactor 和 Handler 都通过 Asynchronous Operation Processor 注册到内核；</li><li>Asynchronous Operation Processor 负责处理注册请求，并处理 I/O 操作；</li><li>Asynchronous Operation Processor 完成 I/O 操作后通知 Proactor；</li><li>Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理；</li><li>Handler 完成业务处理；</li></ul><h2 id="一致性哈希"><a class="anchor" href="#一致性哈希">#</a> 一致性哈希</h2><p>一致哈希算法是对 2^32 进行取模运算，是一个固定的值，将「存储节点」和「数据」都映射到一个首尾相连的哈希环上。</p><p>映射的结果值往顺时针的方向的找到第一个节点，就是存储该数据的节点</p><p><img data-src="960b4f5bfc7247a7aa2849de9798aead.png" alt="截图">在一致哈希算法中，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响。</p><p>一致性哈希算法虽然减少了数据迁移量，但是存在节点分布不均匀的问题</p><h3 id="采用虚拟节点"><a class="anchor" href="#采用虚拟节点">#</a> 采用虚拟节点</h3><p><img data-src="ad77d7fcc911bb082f2aacca8ee95a7a.png" alt="截图"></p><p>当节点变化时，会有不同的节点共同分担系统的变化，因此稳定性更高</p><div class="tags"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" rel="tag"><i class="ic i-tag"></i> 计算机科学</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-06-30 10:39:59" itemprop="dateModified" datetime="2023-06-30T10:39:59+08:00">2023-06-30</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Umi <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="http://lovearrowshoot.github.io/CS/OS/" title="操作系统">http://lovearrowshoot.github.io/CS/OS/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/CS/CN/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;umi-blog-delta.vercel.app&#x2F;gh&#x2F;LoveArrowShoot&#x2F;image-bed@main&#x2F;blog-img&#x2F;564SR-Minami-Kotori-How-Was-That-Angelic-Angel-XawtsM.png" title="计算机网络"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 计算机科学</span><h3>计算机网络</h3></a></div><div class="item right"><a href="/DB/MySQL/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;umi-blog-delta.vercel.app&#x2F;gh&#x2F;LoveArrowShoot&#x2F;image-bed@main&#x2F;blog-img&#x2F;631UR-Minami-Kotori-Off-It-Goes-Whoop-Year-of-the-Tiger-Unit-Assemble-lFbHU0.png" title="MySQL"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 数据库</span><h3>MySQL</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%A7%88"><span class="toc-number">1.</span> <span class="toc-text">概览</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">硬件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">冯诺依曼模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.2.</span> <span class="toc-text">存储器层次关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">2.1.</span> <span class="toc-text">虚拟内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5"><span class="toc-number">2.2.</span> <span class="toc-text">内存分页</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5"><span class="toc-number">2.3.</span> <span class="toc-text">内存分段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98"><span class="toc-number">2.4.</span> <span class="toc-text">段页式内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E5%86%85%E5%AD%98"><span class="toc-number">2.5.</span> <span class="toc-text">Linux 内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="toc-number">2.6.</span> <span class="toc-text">内存回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">2.7.</span> <span class="toc-text">页面置换算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lru%E7%AE%97%E6%B3%95%E6%94%B9%E8%BF%9B"><span class="toc-number">2.8.</span> <span class="toc-text">LRU 算法改进</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">进程和线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">3.2.</span> <span class="toc-text">进程状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">3.3.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pcb%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">3.3.1.</span> <span class="toc-text">PCB（进程控制块）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">进程调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">3.5.</span> <span class="toc-text">进程通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%86%B2%E7%AA%81"><span class="toc-number">3.6.</span> <span class="toc-text">线程冲突</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">3.7.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.7.1.</span> <span class="toc-text">产生条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F"><span class="toc-number">3.7.2.</span> <span class="toc-text">解决方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.</span> <span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="toc-number">4.1.</span> <span class="toc-text">基本组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8"><span class="toc-number">4.2.</span> <span class="toc-text">文件存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">索引方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.2.</span> <span class="toc-text">存储结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6io"><span class="toc-number">4.3.</span> <span class="toc-text">文件 IO</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.</span> <span class="toc-text">网络系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93"><span class="toc-number">5.1.</span> <span class="toc-text">网络传输</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%8B%B7%E8%B4%9D"><span class="toc-number">5.1.1.</span> <span class="toc-text">传统拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">5.1.2.</span> <span class="toc-text">零拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">5.2.</span> <span class="toc-text">IO 多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#selectpoll"><span class="toc-number">5.2.1.</span> <span class="toc-text">select&#x2F;poll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll"><span class="toc-number">5.2.2.</span> <span class="toc-text">epoll</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">网络模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#reactor"><span class="toc-number">5.3.1.</span> <span class="toc-text">Reactor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proactor"><span class="toc-number">5.3.2.</span> <span class="toc-text">Proactor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="toc-number">5.4.</span> <span class="toc-text">一致性哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9"><span class="toc-number">5.4.1.</span> <span class="toc-text">采用虚拟节点</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/CS/CN/" rel="bookmark" title="计算机网络">计算机网络</a></li><li class="active"><a href="/CS/OS/" rel="bookmark" title="操作系统">操作系统</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Umi" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Umi</p><div class="description" itemprop="description">这只是我闲着无聊搭的一个博客，主要用于存放笔记，顺便厨力放出</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">10</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xvdmVBcnJvd1Nob290" title="https:&#x2F;&#x2F;github.com&#x2F;LoveArrowShoot"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9seHgxNTkxMTA=" title="https:&#x2F;&#x2F;twitter.com&#x2F;lxx159110"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9tYXJ2ZWxmZw==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;marvelfg"><i class="ic i-zhihu"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>直达</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/CS/CN/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/DB/MySQL/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Algorithms/" title="分类于 算法">算法</a></div><span><a href="/Algorithms/ACM/" title="ACM常用输入输出">ACM常用输入输出</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/DB/" title="分类于 数据库">数据库</a></div><span><a href="/DB/MySQL/" title="MySQL">MySQL</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/hexo/" title="分类于 Hexo">Hexo</a></div><span><a href="/hexo/hexo/" title="Hexo-Shoka主题的配置和使用">Hexo-Shoka主题的配置和使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Algorithms/" title="分类于 算法">算法</a></div><span><a href="/Algorithms/%E7%AE%97%E6%B3%95/" title="常见算法">常见算法</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CS/" title="分类于 计算机科学">计算机科学</a></div><span><a href="/CS/CN/" title="计算机网络">计算机网络</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/hexo/" title="分类于 Hexo">Hexo</a></div><span><a href="/hexo/hexo-fullscreen/" title="Hexo-shoka自定义">Hexo-shoka自定义</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CS/" title="分类于 计算机科学">计算机科学</a></div><span><a href="/CS/OS/" title="操作系统">操作系统</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/DP/" title="分类于 设计模式">设计模式</a></div><span><a href="/DP/DP/" title="设计模式详解">设计模式详解</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/cpp/" title="分类于 C++">C++</a></div><span><a href="/cpp/C++11%E7%89%B9%E8%89%B2/" title="C++11特色">C++11特色</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/DB/" title="分类于 数据库">数据库</a></div><span><a href="/DB/Redis/" title="Redis">Redis</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Umi @ umiの道場</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">36k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">33 分钟</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"CS/OS/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->